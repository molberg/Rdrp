# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Get header information from a GILDAS/CLASS single dish data file
#'
#' Given a filename, open the file and scan it for single dish spectra
#' or continuum scans. A data frame is returned where each row corresponds
#' to the header information of one scan in the file.
#' @param filename name of the GILDAS/CLASS file including path to be opened
#' @return data frame with n rows, where n is the number of scans found
#' @examples
#' filename = "mydata.apex"
#' H <- getClassHeader(filename)
#' print(H)           # print the resulting data frame
#' print(summary(H))  # print a summary
getClassHeader <- function(filename) {
    .Call('_Rdrp_getClassHeader', PACKAGE = 'Rdrp', filename)
}

#' Read a GILDAS/CLASS single dish data file
#'
#' Given a filename of a GILDAS/CLASS data file and a data frame 'header',
#' open the file and scan it for single dish spectra or continuum scans.
#' For each row in the header frame, the corresponding scan will be returned
#' as a list with a head, freq and data section. For continuum scans, the
#' frequency vector will simply be a running index. All the individual lists are
#' combined into one major list, which is returned. If you supplied a header
#' and run getHead(L) on the returned list L, you should get your header back.
#' If a header is not supplied, it will be constructed on the fly, such that
#' all scans present in the CLASS file will be returned. Note that this may
#' result in running out of memory for very large (several Gb) files.
#' @param filename name of the GILDAS/CLASS file including path to be opened
#' @param H a data frame with one row for each scan requested (optional).
#' @return list of length n, where n is the number of scans.
#' @examples
#' \dontrun{
#' filename = "mydata.apex"
#' H <- getClassHeader(filename)
#' L = readClass(filename)      # return all spectra in file
#' H <- H[which(H$target == "RDor" & H$line == "CO (6-5)"),]
#' L = readClass(filename, H)   # return only RDor CO (6-5) spectra
#' }
readClass <- function(filename, H = NULL) {
    .Call('_Rdrp_readClass', PACKAGE = 'Rdrp', filename, H)
}

#' Get frequency vectors
#'
#' From a list of spectra, get the frequency vectors and return as matrix.
#' @param L a list of spectra, each with components 'head', 'freq' and 'data'
#' @return a matrix having all the frequency vectors as columns
#' @seealso \code{\link{getVelo}}
getFreq <- function(L) {
    .Call('_Rdrp_getFreq', PACKAGE = 'Rdrp', L)
}

#' Construct frequency vector
#'
#' Turn a given velocity vector into a frequency vector.
#'
#' @param S a single spectrum
#' @param v a numeric vector holding velocities
#' @return a numeric vector holding frequencies
#' @seealso \code{\link{velocities}}
#' @examples
#' # resample spectrum at particular velocities
#' \dontrun{
#' v <- seq(-100,100,by=2)
#' R <- resample(S, frequencies(S,v))
#' }
#' NULL
frequencies <- function(S, v) {
    .Call('_Rdrp_frequencies', PACKAGE = 'Rdrp', S, v)
}

#' Construct velocity vector
#'
#' Turn the frequency vector into a velocity vector.
#'
#' @param S a single spectrum
#' @return a numeric vector holding velocities
#' @seealso \code{\link{frequencies}}
velocities <- function(S) {
    .Call('_Rdrp_velocities', PACKAGE = 'Rdrp', S)
}

#' Get velocity vectors
#'
#' From a list of spectra, get the velocity vectors and return as matrix.
#' @param L a list of spectra, each with components 'head', 'freq' and 'data'
#' @return a matrix having all the velcity vectors as columns
#' @seealso \code{\link{getFreq}}
getVelo <- function(L) {
    .Call('_Rdrp_getVelo', PACKAGE = 'Rdrp', L)
}

#' Get data vectors
#'
#' From a list of spectra, get the data vectors and return as matrix.
#' @param L a list of spectra, each with components 'head', 'freq' and 'data'
#' @return a matrix having all the data vectors as columns
#' @seealso \code{\link{getFreq}}, \code{\link{getVelo}}
#' @examples
#' data(salsa)
#' D <- getData(salsa)
#' image(D)             # show data matrix as color image
getData <- function(L) {
    .Call('_Rdrp_getData', PACKAGE = 'Rdrp', L)
}

#' Get dimensions
#'
#' From a list of spectra, get the dimensions of the data.
#' @param L a list of spectra, each with components 'head', 'freq' and 'data'
#' @return a two component integer vector (nChannels, nSpectra)
getDimension <- function(L) {
    .Call('_Rdrp_getDimension', PACKAGE = 'Rdrp', L)
}

#' Calculate average spectrum
#'
#' From a list of spectra, calculate the average spectrum where the weighting is
#' done using system temperature and integration times of the headers.
#'
#' @param L a list of spectra, each with components 'head', 'freq' and 'data'
#' @return the average spectrum
#' @examples
#' data(salsa)
#' A <- average(salsa)
#' plot(salsa)                              # plot individual spectra
#' lines(A$freq, A$data, lwd=5, col='red')  # draw average spectrum on top
average <- function(L) {
    .Call('_Rdrp_average', PACKAGE = 'Rdrp', L)
}

foo <- function(S) {
    .Call('_Rdrp_foo', PACKAGE = 'Rdrp', S)
}

#' Fold a frequency switched spectrum
#'
#' @param S a single spectrum
#' @param ft frequency requency throw in Mhz
#' @param shift if TRUE, assume symmetric switching around true, centre frequency
#' @return the folded spectrum
fold <- function(S, ft, shift = FALSE) {
    .Call('_Rdrp_fold', PACKAGE = 'Rdrp', S, ft, shift)
}

#' Reverse a spectrum
#'
#' Reverse the order of the channels, i.e. turn both the frequency and data
#' vector around.
#' @param S a single spectrum
#' @return the reversed spectrum
reverse <- function(S) {
    .Call('_Rdrp_reverse', PACKAGE = 'Rdrp', S)
}

#' Calculate integrated area
#'
#' Given a mask defining the spectral areas of interest, return the integrated
#' area over those region(s).
#' @param S a single spectrum
#' @param mask a logical vector equal to TRUE for all the channels that should
#'        be integrated.
#' @return the integrated value
#' @examples
#' data(salsa)
#' options(system="velocity")    # work in velocity space
#' S <- salsa[[1]]               # get the first spectrum
#' v <- velocities(S)            # get velocity vector
#' mask <- (v > -20) & (v < 20)  # integrate from -20..20 km/s
#' area(S, mask)                 # calculate integrated area in K*km/s
#' # call 'area' for each of the spectra in 'salsa' with parameter 'mask'
#' sapply(salsa, FUN=area, mask)
area <- function(S, mask) {
    .Call('_Rdrp_area', PACKAGE = 'Rdrp', S, mask)
}

#' Calculate moments
#'
#' Given a mask defining the spectral areas of interest, return the integrated
#' area over those region(s).
#' @param S a single spectrum
#' @param mask a logical vector equal to TRUE for all the channels that should
#'        be integrated.
#' @return a data frame containing minimum, maximum, mean, sdev, skewness and kurtosis
#' @seealso \code{\link{area}}
#' @examples
#' data(salsa)
#' A <- average(salsa)
#' # calculate moments between 1420...1421 MHz
#' lmask <- mask(A, c(1420,1421))
#' moment(A, mask=lmask)
#' # do this for individual spectra
#' do.call("rbind", lapply(salsa, moment, lmask))
moment <- function(S, mask) {
    .Call('_Rdrp_moment', PACKAGE = 'Rdrp', S, mask)
}

#' Trim channels from spectra
#'
#' Given a single spectrum and a vector of channel numbers, trim the spectrum such that
#' only the given channels are kept in the frequency and data vectors.
#'
#' @param S a single spectrum
#' @param keep a vector holding the channel numbers to keep
#' @return the trimmed spectrum
trim <- function(S, keep) {
    .Call('_Rdrp_trim', PACKAGE = 'Rdrp', S, keep)
}

#' Filter spectrum
#'
#' Perform filtering on a single spectrum.
#'
#' @param S a single spectrum
#' @param coeffs a numeric vector with an odd number of filter coefficients
#' @return the filtered spectrum
sieve <- function(S, coeffs) {
    .Call('_Rdrp_sieve', PACKAGE = 'Rdrp', S, coeffs)
}

#' Resample spectrum
#'
#' Perform resampling (cubic spline interpolation) on a single spectrum.
#'
#' @param S a single spectrum
#' @param f a frequency vector onto which the spectrum should be resampled
#' @param smooth if TRUE convolve with Gaussian response
#' @return the resampled spectrum
resample <- function(S, f, smooth = FALSE) {
    .Call('_Rdrp_resample', PACKAGE = 'Rdrp', S, f, smooth)
}

#' Rescale spectrum
#'
#' Add bias and/or scale by factor.
#'
#' @param S a single spectrum
#' @param factor a numeric value by which to scale the whole spectrum
#' @param bias a numeric value to add to all channels
#' @return the rescaled spectrum, out = in * factor + bias
rescale <- function(S, factor = 1.0, bias = 0.0) {
    .Call('_Rdrp_rescale', PACKAGE = 'Rdrp', S, factor, bias)
}

#' Construct a line mask
#'
#' For a given set of frequency (or velocity) windows, construct a
#' matrix of logical values, defining the areas which should not be used
#' in baseline fitting.
#' @param S a single spectrum
#' @param limits pairs of values, which each define a window
#' @return a vector of logical values, one per channel
mask <- function(S, limits) {
    .Call('_Rdrp_mask', PACKAGE = 'Rdrp', S, limits)
}

#' Get a spectrum from an Odin binary file on disk
#'
#' Take a file name of a singular Odin scan in binary format and return a spectrum
#' (i.e. a list consisting of header, frequency and data vectors).
#' @param filenam file name) including path of the binary file to read
#' @return a list with components head, freq and data
#' @examples
#' filename = "AOS.278372EA.AVE"
#' s <- getOdinSpectrum(filename)
#' print(s$head)      # print spectrum header
#' plot(s)            # plot the spectrum
getOdinSpectrum <- function(filename) {
    .Call('_Rdrp_getOdinSpectrum', PACKAGE = 'Rdrp', filename)
}

