# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Get header information from a GILDAS/CLASS single dish data file
#'
#' Given a filename, open the file and scan it for single dish spectra
#' or continuum scans. A data frame is returned where each row corresponds
#' to the header information of one scan in the file.
#' @param filename name of the GILDAS/CLASS file including path to be opened
#' @return data frame with n rows, where n is the number of scans found
#' @examples
#' filename = "mydata.apex"
#' H <- getClassHeader(filename)
#' print(H)           # print the resulting data frame
#' print(summary(H))  # print a summary
#' @export
getClassHeader <- function(filename) {
    .Call('_Rdrp_getClassHeader', PACKAGE = 'Rdrp', filename)
}

#' Read a GILDAS/CLASS single dish data file
#'
#' Given a filename of a GILDAS/CLASS data file and a data frame 'header',
#' open the file and scan it for single dish spectra or continuum scans.
#' For each row in the header frame, the corresponding scan will be returned
#' as a list with a head, freq and data section. For continuum scans, the
#' frequency vector will simply be a running index. All the individual lists are
#' combined into one major list, which is returned. If you supplied a header
#' and run getHead(L) on the returned list L, you should get your header back.
#' If a header is not supplied, it will be constructed on the fly, such that
#' all scans present in the CLASS file will be returned. Note that this may
#' result in running out of memory for very large (several Gb) files.
#' @param filename name of the GILDAS/CLASS file including path to be opened
#' @param H a data frame with one row for each scan requested (optional).
#' @return list of length n, where n is the number of scans.
#' @examples
#' \dontrun{
#' filename = "mydata.apex"
#' H <- getClassHeader(filename)
#' L = readClass(filename)      # return all spectra in file
#' H <- H[which(H$target == "RDor" & H$line == "CO (6-5)"),]
#' L = readClass(filename, H)   # return only RDor CO (6-5) spectra
#' }
#' @export
readClass <- function(filename, H = NULL) {
    .Call('_Rdrp_readClass', PACKAGE = 'Rdrp', filename, H)
}

#' Get frequency vectors
#'
#' From a list of spectra, get the frequency vectors and return as matrix.
#' @param L a list of spectra, each with components 'head', 'freq' and 'data'
#' @return a matrix having all the frequency vectors as columns
#' @seealso \code{\link{getVelo}}
#' @export
getFreq <- function(L) {
    .Call('_Rdrp_getFreq', PACKAGE = 'Rdrp', L)
}

#' Construct frequency vector
#'
#' Turn a given velocity vector into a frequency vector.
#'
#' @param S a single spectrum
#' @param v a numeric vector holding velocities
#' @return a numeric vector holding frequencies
#' @seealso \code{\link{velocities}}
#' @examples
#' # resample spectrum at particular velocities
#' \dontrun{
#' v <- seq(-100,100,by=2)
#' R <- resample(S, frequencies(S,v))
#' }
#' NULL
#' @export
frequencies <- function(S, v) {
    .Call('_Rdrp_frequencies', PACKAGE = 'Rdrp', S, v)
}

#' Construct velocity vector
#'
#' Turn the frequency vector into a velocity vector.
#'
#' @param S a single spectrum
#' @return a numeric vector holding velocities
#' @seealso \code{\link{frequencies}}
#' @export
velocities <- function(S) {
    .Call('_Rdrp_velocities', PACKAGE = 'Rdrp', S)
}

#' Get velocity vectors
#'
#' From a list of spectra, get the velocity vectors and return as matrix.
#' @param L a list of spectra, each with components 'head', 'freq' and 'data'
#' @return a matrix having all the velcity vectors as columns
#' @seealso \code{\link{getFreq}}
#' @export
getVelo <- function(L) {
    .Call('_Rdrp_getVelo', PACKAGE = 'Rdrp', L)
}

#' Get data vectors
#'
#' From a list of spectra, get the data vectors and return as matrix.
#' @param L a list of spectra, each with components 'head', 'freq' and 'data'
#' @return a matrix having all the data vectors as columns
#' @seealso \code{\link{getFreq}}, \code{\link{getVelo}}
#' @examples
#' data(salsa)
#' D <- getData(salsa)
#' image(D)             # show data matrix as color image
#' @export
getData <- function(L) {
    .Call('_Rdrp_getData', PACKAGE = 'Rdrp', L)
}

#' Get dimensions
#'
#' From a list of spectra, get the dimensions of the data.
#' @param L a list of spectra, each with components 'head', 'freq' and 'data'
#' @return a two component integer vector (nChannels, nSpectra)
#' @export
getDimension <- function(L) {
    .Call('_Rdrp_getDimension', PACKAGE = 'Rdrp', L)
}

#' Calculate average spectrum
#'
#' From a list of spectra, calculate the average spectrum where the weighting is
#' done using system temperature and integration times of the headers.
#'
#' @param L a list of spectra, each with components 'head', 'freq' and 'data'
#' @return the average spectrum
#' @examples
#' data(salsa)
#' A <- average(salsa)
#' plot(salsa)                              # plot individual spectra
#' lines(A$freq, A$data, lwd=5, col='red')  # draw average spectrum on top
#' @export
average <- function(L) {
    .Call('_Rdrp_average', PACKAGE = 'Rdrp', L)
}

foo <- function(S) {
    .Call('_Rdrp_foo', PACKAGE = 'Rdrp', S)
}

#' Fold a frequency switched spectrum
#'
#' @param S a single spectrum
#' @param ft frequency requency throw in Mhz
#' @param shift if TRUE, assume symmetric switching around true, centre frequency
#' @return the folded spectrum
#' @export
fold <- function(S, ft, shift = FALSE) {
    .Call('_Rdrp_fold', PACKAGE = 'Rdrp', S, ft, shift)
}

#' Reverse a spectrum
#'
#' Reverse the order of the channels, i.e. turn both the frequency and data
#' vector around.
#' @param S a single spectrum
#' @return the reversed spectrum
#' @export
reverse <- function(S) {
    .Call('_Rdrp_reverse', PACKAGE = 'Rdrp', S)
}

#' Calculate integrated area
#'
#' Given a mask defining the spectral areas of interest, return the integrated
#' area over those region(s).
#' @param S a single spectrum
#' @param mask a logical vector equal to TRUE for all the channels that should
#'        be integrated.
#' @return the integrated value
#' @examples
#' data(salsa)
#' options(system="velocity")    # work in velocity space
#' S <- salsa[[1]]               # get the first spectrum
#' v <- velocities(S)            # get velocity vector
#' mask <- (v > -20) & (v < 20)  # integrate from -20..20 km/s
#' area(S, mask)                 # calculate integrated area in K*km/s
#' # call 'area' for each of the spectra in 'salsa' with parameter 'mask'
#' sapply(salsa, FUN=area, mask)
#' @export
area <- function(S, mask) {
    .Call('_Rdrp_area', PACKAGE = 'Rdrp', S, mask)
}

#' Calculate moments
#'
#' Given a mask defining the spectral areas of interest, return the integrated
#' area over those region(s).
#' @param S a single spectrum
#' @param mask a logical vector equal to TRUE for all the channels that should
#'        be integrated.
#' @return a data frame containing minimum, maximum, mean, sdev, skewness and kurtosis
#' @seealso \code{\link{area}}
#' @examples
#' data(salsa)
#' A <- average(salsa)
#' # calculate moments between 1420...1421 MHz
#' lmask <- mask(A, c(1420,1421))
#' moment(A, mask=lmask)
#' # do this for individual spectra
#' do.call("rbind", lapply(salsa, moment, lmask))
#' @export
moment <- function(S, mask) {
    .Call('_Rdrp_moment', PACKAGE = 'Rdrp', S, mask)
}

#' Trim channels from spectra
#'
#' Given a single spectrum and a vector of channel numbers, trim the spectrum such that
#' only the given channels are kept in the frequency and data vectors.
#'
#' @param S a single spectrum
#' @param keep a vector holding the channel numbers to keep
#' @return the trimmed spectrum
#' @export
trim <- function(S, keep) {
    .Call('_Rdrp_trim', PACKAGE = 'Rdrp', S, keep)
}

#' Filter spectrum
#'
#' Perform filtering on a single spectrum.
#'
#' @param S a single spectrum
#' @param coeffs a numeric vector with an odd number of filter coefficients
#' @return the filtered spectrum
#' @export
sieve <- function(S, coeffs) {
    .Call('_Rdrp_sieve', PACKAGE = 'Rdrp', S, coeffs)
}

#' Resample spectrum
#'
#' Perform resampling (cubic spline interpolation) on a single spectrum.
#'
#' @param S a single spectrum
#' @param f a frequency vector onto which the spectrum should be resampled
#' @param smooth if TRUE convolve with Gaussian response
#' @return the resampled spectrum
#' @export
resample <- function(S, f, smooth = FALSE) {
    .Call('_Rdrp_resample', PACKAGE = 'Rdrp', S, f, smooth)
}

#' Rescale spectrum
#'
#' Add bias and/or scale by factor.
#'
#' @param S a single spectrum
#' @param factor a numeric value by which to scale the whole spectrum
#' @param bias a numeric value to add to all channels
#' @return the rescaled spectrum, out = in * factor + bias
#' @export
rescale <- function(S, factor = 1.0, bias = 0.0) {
    .Call('_Rdrp_rescale', PACKAGE = 'Rdrp', S, factor, bias)
}

#' Construct a line mask
#'
#' For a given set of frequency (or velocity) windows, construct a
#' matrix of logical values, defining the areas which should not be used
#' in baseline fitting.
#' @param S a single spectrum
#' @param limits pairs of values, which each define a window
#' @return a vector of logical values, one per channel
#' @export
mask <- function(S, limits) {
    .Call('_Rdrp_mask', PACKAGE = 'Rdrp', S, limits)
}

#' Get one column of header data.
#'
#' Given a list L, where each list member is itself a list with
#' components 'head' (which is a list or a dataframe with one row),
#' 'freq' (a numeric vector) and 'data' (another numeric vector of same
#' length as freq), return all the 'head' components as a data frame,
#' which will have as many rows as the length of the original list.
#'
#' It is assumed that all 'head' components have the same number of
#' members with identical names and types.
#'
#' @param L a list of spectra, each with components 'head', 'freq' and 'data'
#' @param index the index of the column to be retrieved
#' @return a data.frame formed by row-binding all the individual 'head's
#' @seealso \code{\link{modify}}
#' @examples
#' S1 <- list(head=list(target="Orion", ra=1.23, dec=-0.5, dt=as.integer(20)),
#'            freq=-5:5, data=rnorm(11))
#' S2 <- list(head=list(target="SgrB2", ra=5.43, dec=+0.5, dt=as.integer(20)),
#'            freq=-5:5, data=rnorm(11))
#' L <- list(S1,S2)
#' class(L) <- "spectra"
#' i <- which(names(S1$head) == "ra")
#' getHeaderColumn(L, i)
#'
#' # will result in
#'
#' # [1] 1.23 5.43
#'
#' @export
getHeaderColumn <- function(L, index) {
    .Call('_Rdrp_getHeaderColumn', PACKAGE = 'Rdrp', L, index)
}

#' Get header data.
#'
#' Given a list L, where each list member is itself a list with
#' components 'head' (which is a list or a dataframe with one row),
#' 'freq' (a numeric vector) and 'data' (another numeric vector of same
#' length as freq), return all the 'head' components as a data frame,
#' which will have as many rows as the length of the original list.
#'
#' It is assumed that all 'head' components have the same number of
#' members with identical names and types.
#'
#' @param L a list of spectra, each with components 'head', 'freq' and 'data'
#' @return a data.frame formed by row-binding all the individual 'head's
#' @seealso \code{\link{modify}}
#' @examples
#' S1 <- list(head=list(target="Orion", ra=1.23, dec=-0.5, dt=as.integer(20)),
#'            freq=-5:5, data=rnorm(11))
#' S2 <- list(head=list(target="SgrB2", ra=5.43, dec=+0.5, dt=as.integer(20)),
#'            freq=-5:5, data=rnorm(11))
#' L <- list(S1,S2)
#' class(L) <- "spectra"
#' getHead(L)
#'
#' # will result in
#'
#' #   target   ra  dec dt
#' # 1  Orion 1.23 -0.5 20
#' # 2  SgrB2 5.43  0.5 20
#'
#' @export
getHead <- function(L) {
    .Call('_Rdrp_getHead', PACKAGE = 'Rdrp', L)
}

#' Get a spectrum from an Odin binary file on disk
#'
#' Take a file name of a singular Odin scan in binary format and return a spectrum
#' (i.e. a list consisting of header, frequency and data vectors).
#' @param filename file name including path of the binary file to read
#' @return a list with components head, freq and data
#' @examples
#' \dontrun{
#' filenames <- list.files(datadir, patter="SPE")
#' L <- lapply(filenames, getOdinSpectrum)
#' class(L) <- "spectra"
#' H <- getHead(L)
#' print(H)
#' }
#' @export
getOdinSpectrum <- function(filename) {
    .Call('_Rdrp_getOdinSpectrum', PACKAGE = 'Rdrp', filename)
}

