# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Read a GILDAS/CLASS single dish data file
#'
#' Given a filename, open the file and scan it for single dish spectra
#' or continuum scans. Each encountered scan is returned as a list with
#' a head, freq and data section. For continuum scans, the frequency
#' vector will simply be a running index. All the individual lists are
#' combined into one major list, which is returned.
#' @param filename name of the GILDAS file including path to be opened
#' @return list of length n, where n is the number of scans found
readClass <- function(filename) {
    .Call('Rdrp_readClass', PACKAGE = 'Rdrp', filename)
}

#' Get header data.
#'
#' Given a list L, where each list member is itself a list with
#' components 'head' (which is a list or a dataframe with one row),
#' 'freq' (a numeric vector) and 'data' (another numeric vector of same
#' length as freq), return all the 'head'components as a dataframe,
#' which will have as many rows as the length of the original list.
#'
#' It is assumed that all 'head' components have the same number of
#' members with identical names and types.
#'
#' @param L a list of spectra, each with components 'head', 'freq' and 'data'
#' @return a data.frame formed by row-binding all the individual 'head's
#' @seealso \code{\link{addColumns}}, \code{\link{modify}}
#' @examples
#' S1 <- list(head=list(target="Orion", ra=1.23, dec=-0.5, dt=as.integer(20)), freq=-5:5, data=rnorm(11))
#' S2 <- list(head=list(target="SgrB2", ra=5.43, dec=+0.5, dt=as.integer(20)), freq=-5:5, data=rnorm(11))
#'
#' getHead(list(S1,S2))
#'
#' # will result in
#'
#' #   target   ra  dec dt
#' # 1  Orion 1.23 -0.5 20
#' # 2  SgrB2 5.43  0.5 20
#'
getHead <- function(L) {
    .Call('Rdrp_getHead', PACKAGE = 'Rdrp', L)
}

#' Get frequency vectors
#'
#' From a list of spectra, get the frequency vectors and return as matrix.
#' @param L a list of spectra, each with components 'head', 'freq' and 'data'
#' @return a matrix having all the frequency vectors as columns
#' @seealso \code{\link{getVelo}}
getFreq <- function(L) {
    .Call('Rdrp_getFreq', PACKAGE = 'Rdrp', L)
}

#' Construct frequency vector
#'
#' Turn a given velocity vector into a frequency vector.
#'
#' @param S a single spectrum
#' @param v a numeric vector holding velocities
#' @return a numeric vector holding frequencies
#' @seealso \code{\link{velocities}}
#' @examples
#' # resample spectrum at particular velocities
#' v <- seq(-100,100,by=2)
#' R <- resample(S, frequencies(S,v))
frequencies <- function(S, v) {
    .Call('Rdrp_frequencies', PACKAGE = 'Rdrp', S, v)
}

#' Construct velocity vector
#'
#' Turn the frequency vector into a velocity vector.
#'
#' @param S a single spectrum
#' @return a numeric vector holding velocities
#' @seealso \code{\link{frequencies}}
velocities <- function(S) {
    .Call('Rdrp_velocities', PACKAGE = 'Rdrp', S)
}

#' Get velocity vectors
#'
#' From a list of spectra, get the velocity vectors and return as matrix.
#' @param L a list of spectra, each with components 'head', 'freq' and 'data'
#' @return a matrix having all the velcity vectors as columns
#' @seealso \code{\link{getFreq}}
getVelo <- function(L) {
    .Call('Rdrp_getVelo', PACKAGE = 'Rdrp', L)
}

#' Get data vectors
#'
#' From a list of spectra, get the data vectors and return as matrix.
#' @param L a list of spectra, each with components 'head', 'freq' and 'data'
#' @return a matrix having all the data vectors as columns
#' @seealso \code{\link{getFreq}}, \code{\link{getVelo}}
#' @examples
#' data(salsa)
#' D <- getData(salsa)
#' image(D)             # show data matrix as color image
getData <- function(L) {
    .Call('Rdrp_getData', PACKAGE = 'Rdrp', L)
}

#' Get dimensions
#'
#' From a list of spectra, get the dimensions of the data.
#' @param L a list of spectra, each with components 'head', 'freq' and 'data'
#' @return a two component integer vector (nChannels, nSpectra)
getDimension <- function(L) {
    .Call('Rdrp_getDimension', PACKAGE = 'Rdrp', L)
}

#' Calculate average spectrum
#'
#' From a list of spectra, calculate the average spectrum where the weighting is
#' done using system temperature and integration times of the headers.
#'
#' @param L a list of spectra, each with components 'head', 'freq' and 'data'
#' @return the average spectrum
#' @examples
#' data(salsa)
#' A <- average(salsa)
#' plot(salsa)                              # plot individual spectra
#' lines(A$freq, A$data, lwd=5, col='red')  # draw average spectrum on top
average <- function(L) {
    .Call('Rdrp_average', PACKAGE = 'Rdrp', L)
}

#' Modify a header column
#'
#' Supply new values for a column of the header
#' @param L a list of spectra
#' @param column a string specifying which header column to modify
#' @param value a vector holding the new values of the header column
modify <- function(L, column, value) {
    invisible(.Call('Rdrp_modify', PACKAGE = 'Rdrp', L, column, value))
}

#' Add header columns
#'
#' Add new columns to the header part of the spectra, you may fill these new
#' columns by using routine 'modify'.
#' @param L a list of spectra
#' @param newnames a character vector holding an array of column names to be
#'        added to the header
#' @seealso \code{\link{modify}}
#' @examples
#' data(salsa)
#' print(getHead(salsa))
#' addColumns(salsa, "T.sys")
#' modify(salsa, "T.sys", rep(300.0, 29))
#' print(getHead(salsa))    # header should now have additional column T.sys
addColumns <- function(L, newnames) {
    invisible(.Call('Rdrp_addColumns', PACKAGE = 'Rdrp', L, newnames))
}

bar <- function(which) {
    .Call('Rdrp_bar', PACKAGE = 'Rdrp', which)
}

foo <- function(S) {
    .Call('Rdrp_foo', PACKAGE = 'Rdrp', S)
}

#' Fold a frequency switched spectrum
#'
#' @param S a single spectrum
#' @param ft frequency requency throw in Mhz
#' @param shift if TRUE, assume symmetric switching around true, centre frequency
#' @return the folded spectrum
fold <- function(S, ft, shift = FALSE) {
    .Call('Rdrp_fold', PACKAGE = 'Rdrp', S, ft, shift)
}

#' Reverse a spectrum
#'
#' Reverse the order of the channels, i.e. turn both the frequency and data
#' vector around.
#' @param S a single spectrum
#' @return the reversed spectrum
reverse <- function(S) {
    .Call('Rdrp_reverse', PACKAGE = 'Rdrp', S)
}

#' Calculate integrated area
#'
#' Given a mask defining the spectral areas of interest, return the integrated
#' area over those region(s).
#' @param S a single spectrum
#' @param mask a logical vector equal to TRUE for all the channels that should
#'        be integrated.
#' @return the integrated value
#' @examples
#' data(salsa)
#' assign("system","velocity", Rdrp::options)     # work in velocity space
#' S <- salsa[[1]]               # get the first spectrum
#' v <- velocities(S)            # get velocity vector
#' mask <- (v > -20) & (v < 20)  # integrate from -20..20 km/s
#' area(S, mask)                 # calculate integrated area in K*km/s
#' # call 'area' for each of the spectra in 'salsa' with parameter 'mask'
#' sapply(salsa, FUN=area, mask)
area <- function(S, mask) {
    .Call('Rdrp_area', PACKAGE = 'Rdrp', S, mask)
}

#' Calculate moments
#'
#' Given a mask defining the spectral areas of interest, return the integrated
#' area over those region(s).
#' @param S a single spectrum
#' @param mask a logical vector equal to TRUE for all the channels that should
#'        be integrated.
#' @return a data frame containing minimum, maximum, mean, sdev, skewness and kurtosis
#' @seealso \code{\link{area}}
#' @examples
#' data(salsa)
#' A <- average(salsa)
#' lmask <- mask(A, c(1420,1421))  # calculate moments between 1420...1421 MHz
#' moment(A, mask=lmask)
#' do.call("rbind", lapply(salsa, moment, lmask)) # do this for individual spectra
moment <- function(S, mask) {
    .Call('Rdrp_moment', PACKAGE = 'Rdrp', S, mask)
}

#' Trim channels from spectra
#'
#' Given a single spectrum and a vector of channel numbers, trim the spectrum such that
#' only the given channels are kept in the frequency and data vectors.
#'
#' @param S a single spectrum
#' @param keep a vector holding the channel numbers to keep
#' @return the trimmed spectrum
trim <- function(S, keep) {
    .Call('Rdrp_trim', PACKAGE = 'Rdrp', S, keep)
}

#' Filter spectrum
#'
#' Perform filtering on a single spectrum.
#'
#' @param S a single spectrum
#' @param coeffs a numeric vector with an odd number of filter coefficients
#' @return the filtered spectrum
sieve <- function(S, coeffs) {
    .Call('Rdrp_sieve', PACKAGE = 'Rdrp', S, coeffs)
}

#' Resample spectrum
#'
#' Perform resampling (cubic spline interpolation) on a single spectrum.
#'
#' @param S a single spectrum
#' @param f a frequency vector onto which the spectrum should be resampled
#' @param smooth if TRUE convolve with Gaussian response
#' @return the resampled spectrum
resample <- function(S, f, smooth = FALSE) {
    .Call('Rdrp_resample', PACKAGE = 'Rdrp', S, f, smooth)
}

#' Rescale spectrum
#'
#' Add bias and/or scale by factor.
#'
#' @param S a single spectrum
#' @param factor a numeric value by which to scale the whole spectrum
#' @param bias a numeric value to add to all channels
#' @return the rescaled spectrum, out = in * factor + bias
rescale <- function(S, factor = 1.0, bias = 0.0) {
    .Call('Rdrp_rescale', PACKAGE = 'Rdrp', S, factor, bias)
}

#' Construct a line mask
#'
#' For a given set of frequency (or velocity) windows, construct a
#' matrix of logical values, defining the areas which should not be used
#' in baseline fitting.
#' @param S a single spectrum
#' @param limits pairs of values, which each define a window
#' @return a vector of logical values, one per channel
mask <- function(S, limits) {
    .Call('Rdrp_mask', PACKAGE = 'Rdrp', S, limits)
}

getZeros <- function(n) {
    .Call('Rdrp_getZeros', PACKAGE = 'Rdrp', n)
}

fooData <- function(L) {
    .Call('Rdrp_fooData', PACKAGE = 'Rdrp', L)
}

smooft <- function(S) {
    .Call('Rdrp_smooft', PACKAGE = 'Rdrp', S)
}

