# This file was generated by Rcpp::compileAttributes
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Get header data.
#'
#' Given a list L, where each list member is itself a list with
#' components 'head' (which is a list or a dataframe with one row),
#' 'freq' (a numeric vector) and 'data' (another numeric vector of same
#' length as freq), return all the 'head'components as a dataframe,
#' which will have as many rows as the length of the original list.
#'
#' It is assumed that all 'head' components have the same number of
#' members with identical names and types.
#'
#' @param L a list of spectra (each with components 'head', 'freq' and 'data')
#' @return a data.frame formed by row-binding all the individual 'head'ers
#' @examples
#' S1 <- list(head=list(target="Orion", ra=1.23, dec=-0.5, dt=as.integer(20)), freq=-5:5, data=rnorm(11))
#' S2 <- list(head=list(target="SgrB2", ra=5.43, dec=+0.5, dt=as.integer(20)), freq=-5:5, data=rnorm(11))
#'
#' getHead(list(S1,S2))
#'
#' # will result in
#'
#' #   target   ra  dec dt
#' # 1  Orion 1.23 -0.5 20
#' # 2  SgrB2 5.43  0.5 20
#'
getHead <- function(L) {
    .Call('Rdrp_getHead', PACKAGE = 'Rdrp', L)
}

#' Get frequency vectors
#'
#' From a list of spectra, get the frequency vectors and return as matrix.
#' @param L a list of spectra (each with components 'head', 'freq' and 'data')
#' @return a matrix having all the frequency vectors as columns
getFreq <- function(L) {
    .Call('Rdrp_getFreq', PACKAGE = 'Rdrp', L)
}

#' Construct velocity vector
#'
#' Turn the frequency vector into a velocity vector.
#'
#' @param S a single spectrum
#' @return a numeric vector holding velocities
velocity <- function(S) {
    .Call('Rdrp_velocity', PACKAGE = 'Rdrp', S)
}

#' Get velocity vectors
#'
#' From a list of spectra, get the velocity vectors and return as matrix.
#' @param L a list of spectra (each with components 'head', 'freq' and 'data')
#' @return a matrix having all the velcity vectors as columns
getVelo <- function(L) {
    .Call('Rdrp_getVelo', PACKAGE = 'Rdrp', L)
}

#' Get data vectors
#'
#' From a list of spectra, get the data vectors and return as matrix.
#' @param L a list of spectra (each with components 'head', 'freq' and 'data')
#' @return a matrix having all the data vectors as columns
getData <- function(L) {
    .Call('Rdrp_getData', PACKAGE = 'Rdrp', L)
}

#' Get dimensions
#'
#' From a list of spectra, get the dimensions of the data.
#' @param L a list of spectra (each with components 'head', 'freq' and 'data')
#' @return a two component integer vector (nChannels, nSpectra)
getDimension <- function(L) {
    .Call('Rdrp_getDimension', PACKAGE = 'Rdrp', L)
}

#' Get subset
#'
#' From a list of spectra, get the subset which is described by an index vector.
#' @param L a list of spectra (each with components 'head', 'freq' and 'data')
#' @param index an integer vector holding the indices of the spectra to retrieve
#' @return the requested subset of spectra returned as a list
getSubset <- function(L, index) {
    .Call('Rdrp_getSubset', PACKAGE = 'Rdrp', L, index)
}

#' Calculate average spectrum
#'
#' From a list of spectra, calculate the average spectrum where the weighting is
#' done using system temperature and integration times of the headers.
#'
#' @param L a list of spectra (each with components 'head', 'freq' and 'data')
#' @return the average spectrum
average <- function(L) {
    .Call('Rdrp_average', PACKAGE = 'Rdrp', L)
}

#' Modify a header column
#'
#' Supply new values for a column of the header
#' @param L a list of spectra
#' @param column a string specifying which header column to modify
#' @param value a vector holding the new values of the header column
modify <- function(L, column, value) {
    invisible(.Call('Rdrp_modify', PACKAGE = 'Rdrp', L, column, value))
}

#' Add header columns
#'
#' Add new columns to the header part of the spectra, you may fill these new
#' columns by using routine 'modify'.
#' @param L a list of spectra
#' @param newnames a character vector holding an array of column names to be
#'        added to the header
addColumns <- function(L, newnames) {
    invisible(.Call('Rdrp_addColumns', PACKAGE = 'Rdrp', L, newnames))
}

bar <- function(which) {
    .Call('Rdrp_bar', PACKAGE = 'Rdrp', which)
}

foo <- function(S) {
    .Call('Rdrp_foo', PACKAGE = 'Rdrp', S)
}

#' Fold a frequency switched spectrum
#'
#' @param S a single spectrum
#' @param throw frequency throw in Mhz
#' @return the folded spectrum
fold <- function(S, ft, shift = FALSE) {
    .Call('Rdrp_fold', PACKAGE = 'Rdrp', S, ft, shift)
}

#' Reverse a spectrum
#'
#' Reverse the order of the channels, i.e. turn both the frequency and data
#' vector around.
#' @param S a single spectrum
#' @return the reversed spectrum
reverse <- function(S) {
    .Call('Rdrp_reverse', PACKAGE = 'Rdrp', S)
}

#' Calculate integrated area
#'
#' Given a mask defining the spectral areas of interest, return the integrated
#' area over those region(s).
#' @param S a single spectrum
#' @param mask a logical vector equal to TRUE for all the channels that should
#'        be integrated.
#' @return the integrated value
area <- function(S, mask) {
    .Call('Rdrp_area', PACKAGE = 'Rdrp', S, mask)
}

#' Calculate moments
#'
#' Given a mask defining the spectral areas of interest, return the integrated
#' area over those region(s).
#' @param S a single spectrum
#' @param mask a logical vector equal to TRUE for all the channels that should
#'        be integrated.
#' @return minimum, maximum, mean, rms, skewness and kurtosis
moment <- function(S, mask) {
    .Call('Rdrp_moment', PACKAGE = 'Rdrp', S, mask)
}

#' Trim channels from spectra
#'
#' Given a single spectrum and a vector of channel numbers, trim the spectrum such that
#' only the given channels are kept in the frequency and data vectors.
#'
#' @param S a single spectrum
#' @param keep a vector holding the channel numbers to keep
#' @return the trimmed spectrum
trim <- function(S, keep) {
    .Call('Rdrp_trim', PACKAGE = 'Rdrp', S, keep)
}

#' Filter spectrum
#'
#' Perform filtering on a single spectrum.
#'
#' @param S a single spectrum
#' @param coeffs a numeric vector with an odd number of filter coefficients
#' @return the filtered spectrum
filter <- function(S, coeffs) {
    .Call('Rdrp_filter', PACKAGE = 'Rdrp', S, coeffs)
}

#' Resample spectrum
#'
#' Perform resampling (cubic spline interpolation) on a single spectrum.
#'
#' @param S a single spectrum
#' @param freq1 a frequency vector onto which the spectrum should be resampled.
#' @return the resampled spectrum
resample <- function(S, freq1) {
    .Call('Rdrp_resample', PACKAGE = 'Rdrp', S, freq1)
}

#' Rescale spectrum
#'
#' Add bias and/or scale by factor.
#'
#' @param S a single spectrum
#' @param factor a numeric value by which to scale the whole spectrum
#' @param bias a numeric value to add to all channels
#' @return the rescaled spectrum, out = in * factor + bias
rescale <- function(S, factor = 1.0, bias = 0.0) {
    .Call('Rdrp_rescale', PACKAGE = 'Rdrp', S, factor, bias)
}

#' Construct a line mask
#'
#' For a given set of frequency (or velocity) windows, construct a
#' matrix of logical values, defining the areas which should not be used
#' in baseline fitting.
#' @param S a single spectrum
#' @param limits pairs of values, which each define a window
mask <- function(S, limits) {
    .Call('Rdrp_mask', PACKAGE = 'Rdrp', S, limits)
}

getZeros <- function(n) {
    .Call('Rdrp_getZeros', PACKAGE = 'Rdrp', n)
}

fooData <- function(L) {
    .Call('Rdrp_fooData', PACKAGE = 'Rdrp', L)
}

